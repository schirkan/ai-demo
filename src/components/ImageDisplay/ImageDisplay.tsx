import { useState, useEffect } from "react";
import { createPortal } from "react-dom";
import { LuPaintRoller, LuPaintbrush, LuPaintbrushVertical, LuPalette, LuPaintBucket, LuImage, LuCircleAlert, LuShare } from "react-icons/lu";
import { imageHelpers } from "@/lib/image-helpers";
import { ProviderTiming } from "@/hooks/useImageGeneration";
import styles from './styles.module.css';
import buttonStyles from '../../css/buttonStyles.module.css';

interface ImageDisplayProps {
  image: string | null | undefined;
  timing?: ProviderTiming;
  failed?: boolean;
  fallbackIcon?: React.ReactNode;
  enabled?: boolean;
}

export function ImageDisplay({
  image,
  timing,
  failed,
  fallbackIcon,
}: ImageDisplayProps) {
  const [isZoomed, setIsZoomed] = useState(false);

  // NEU: Icon-Index f√ºr Animation
  const icons = [
    <LuPaintRoller key="roller" />,
    <LuPaintbrush key="brush" />,
    <LuPaintbrushVertical key="brushV" />,
    <LuPalette key="palette" />,
    <LuPaintBucket key="bucket" />,
  ];
  const [iconIndex, setIconIndex] = useState(0);

  useEffect(() => {
    if (timing?.completionTime) return;
    const interval = setInterval(() => {
      setIconIndex((prev) => (prev + 1) % icons.length);
    }, 2000);
    return () => clearInterval(interval);
  }, [timing?.startTime]);

  useEffect(() => {
    if (isZoomed) {
      window.history.pushState({ zoomed: true }, "");
    }

    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === "Escape" && isZoomed) {
        setIsZoomed(false);
      }
    };

    const handlePopState = () => {
      if (isZoomed) {
        setIsZoomed(false);
      }
    };

    if (isZoomed) {
      document.addEventListener("keydown", handleEscape);
      window.addEventListener("popstate", handlePopState);
    }

    return () => {
      document.removeEventListener("keydown", handleEscape);
      window.removeEventListener("popstate", handlePopState);
    };
  }, [isZoomed]);

  const handleImageClick = (e: React.MouseEvent) => {
    if (image) {
      e.stopPropagation();
      setIsZoomed(true);
    }
  };

  const handleActionClick = (
    e: React.MouseEvent,
    imageData: string
  ) => {
    e.stopPropagation();
    imageHelpers.shareOrDownload(imageData, 'image').catch((error) => {
      console.error("Failed to share/download image:", error);
    });
  };

  return (
    <>
      <div onClick={handleImageClick} className={styles.container}>
        {image ? (
          <>
            {/* eslint-disable-next-line @next/next/no-img-element */}
            <img
              src={`data:image/png;base64,${image}`}
              alt={`AI Generated`}
              className="w-full h-full object-cover rounded-lg"
            />
            <button className={buttonStyles.iconButton} onClick={(e) => handleActionClick(e, image)}>
              <LuShare />
              {/* <LuDownload /> */}
            </button>
            {timing?.elapsed && (
              <div>{(timing.elapsed / 1000).toFixed(1)}s</div>
            )}
          </>
        ) : failed ? (
          fallbackIcon || <LuCircleAlert className="h-8 w-8 text-red-500" />
        ) : timing?.startTime ? (
          <div className={styles.loading}>
            {icons[iconIndex]} <span>Generating...</span>
          </div>
        ) : (
          <LuImage className={styles.imagePlaceholder} />
        )}
      </div>

      {isZoomed && image && createPortal(
        <div className={styles.zoomedOverlay} onClick={() => setIsZoomed(false)}>
          {/* eslint-disable-next-line @next/next/no-img-element */}
          <img
            src={`data:image/png;base64,${image}`}
            alt={`Generated by AI`}
            className="max-h-[90dvh] max-w-[90vw] object-contain"
          // onClick={(e) => e.stopPropagation()}
          />
        </div>,
        document.body,
      )}
    </>
  );
}